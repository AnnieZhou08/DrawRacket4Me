<html>
  
</html>

<script>
  
var ProgressStage = {
  OPENBRACKET: 1, //(
  CONSTRUCTOR: 2, //MAKE
  IDENTIFIER: 3, //NODE 
  ARGUMENTS: 4, //VAL KEY LEFT RIGHT
  CLOSEBRACKET: 5 //)
}

function process(block, identity){
  
  var thisProcessStage = ProgressStage.OPENBRACKET;
  var constructor = "";
  var identifier = "";
  var arguments = []; 
  var currentArgument = 0;
  var numOpenBrackets = 0;
  var hadSpace = false;
  var path = []; path.push(-1);
  var layer = 0;
  var alreadyClosed = true; //brackets for (list and (make-node form an even and odd parity; thus we need a boolean to toggle parity values
  var addedLayer = false;
  
  for (var i = 0, s = block.length; i < s; i++){
    var c = block[i];
    
    switch(thisProcessStage){
      case ProgressStage.OPENBRACKET:
        if (c == " "){
          continue;
        } else if (c != "("){
          throw "Error: Bad Syntax";
        } else {
          numOpenBrackets++;
          thisProcessStage = ProgressStage.CONSTRUCTOR;
        }
        break;
      
      case ProgressStage.CONSTRUCTOR:
        if (c == " "){
          continue;
        } else if (constructor == "list"){
          alreadyClosed = false;
          constructor = "";
          numOpenBrackets++;
          path.push(0);
          addedLayer = true;
          layer++;
        } else if (constructor == "make"){
          alreadyClosed = true;  
          if (addedLayer == false){
              path[layer]=path[layer]+1;
            }
            addedLayer = false;
          thisProcessStage = ProgressStage.IDENTIFIER;
        } else if (constructor.length > 4){
          throw "Error: not a constructor";
        } else {
            constructor += c;
        }
        break;
      
      case ProgressStage.IDENTIFIER:
        if (c == " "){
          if (identifier == identity){
            thisProcessStage = ProgressStage.ARGUMENTS;
          } else {
            throw "Error: Identifier undefined";
          }
        } else if (c == ")"){
          throw "Error: Syntax / No Arguments Found";
        } else {
          identifier += c;
        }
        break;
        
      case ProgressStage.ARGUMENTS:
        if (arguments.length == currentArgument){
           arguments[currentArgument]="";
        }
        if (c == " "){
          hadSpace = true;
        } else if (c == ")"){
          numOpenBrackets--;
          if (numOpenBrackets == 0){
            arguments[currentArgument] +="|"+path;
            break;
          } else{
            alreadyClosed = false;
            arguments[currentArgument] += "|" + path + "*" + layer;
            thisProcessStage = ProgressStage.CLOSEBRACKET;
          }
        } else if (c == "("){
          numOpenBrackets++;
          identifier = "";
          constructor = "";
          arguments[currentArgument] +="|"+path+"*"+layer;
          currentArgument++;
          thisProcessStage = ProgressStage.CONSTRUCTOR;
        } else{
          if (hadSpace == true && arguments[currentArgument].length!=0){
            arguments[currentArgument] += ","+c;
            hadSpace = false;
          } else {
            arguments[currentArgument] += c;
          }
        }
        break; 
      case ProgressStage.CLOSEBRACKET:
        if (c == ")" && alreadyClosed ==false){
          arguments[currentArgument] += "|" + path + "*" + layer;
          layer--;
          path.pop();
          alreadyClosed = true;
        } else if (c == " "){
          continue;
        } else if (c == "("){
          constructor = "";
          identifier = "";
          currentArgument++;
          thisProcessStage = ProgressStage.CONSTRUCTOR;
        } else if (c==")") {
          alreadyClosed = false;
        }
        break;
    }
  }
  
  processArguments(arguments);
  
  console.log(constructor);
  console.log(arguments);
  console.log(numOpenBrackets);
  console.log(layer);
    
}

function processArguments(arguments){
  var info = [];
  for (var i = 0; i < arguments.length; i++){
    var arg = arguments[i];
    var sliceIndex = arg.indexOf("*");
    var fieldIndex = arg.indexOf("|");
    
    var fields = arg.substr(0,fieldIndex);
    var path = arg.substring(fieldIndex+1,sliceIndex);
    info[i] = new Array (fields, path);
  }
  console.log(info);
  getChildren (info);
}
  
function getChildren(info){
  for (var j = 0; j < info.length; j++){
    var count = 0;
    var route = info[j][1];
    for (var k = 0; k < info.length; k++){
      if (info[k][1].length == route.length &&
          info[k][1].charAt(info[k][1].length-3) ==
          route.charAt(route.length-3)) {
        count++;
      }
    }
    info[j] = new Array (info[j][0], info[j][1], count, window.innerWidth, window.innerWidth, window.innerHeight);
  }
  info[0][4] /= 2;
  getXCoordinates(info);
  console.log(info);
  return info;
}
// Right now, info = Array(data, path, num-of-siblings, width, x-coordinate, y-coordinate); Note that it is also stored in order of descend.
  
function getXCoordinates(info){
  for (var i = 1; i < info.length; i++){
    if (info[i][1].length == info[i-1][1].length+2){
      //meaning this node is the previous nodes' child
      var siblings = info[i][2];
      var index = parseInt(info[i][1].charAt(info[i][1].length-1));
      var width = info[i-1][3];
      var x_coordinate = info[i-1][4];
      
      var new_width = width/(siblings+1);
      var new_x = x_coordinate + (index - (siblings/2 - 0.5))*new_width;
      
      info[i][3] = new_width;
      info[i][4] = new_x;      
    } else if (info[i][1].length == info[i-1][1].length){ //meaning this node is previous nodes' sibling node
      var index = parseInt(info[i][1].charAt(info[i][1].length-1));
      var width = info[i-1][3];
      var x_coordinate = info[i-1][4];
      
      var new_x = x_coordinate+width;
      
      info[i][3] = width;
      info[i][4] = new_x;
    }else{
      //meaning this layer is done; need to find the nodes' sibling
      for (var j = 1; j < info.length; j++){
        if (info[j][1].length == info[i][1].length &&
            info[j][1].charAt(info[j][1].length-3) ==
            info[i][1].charAt(info[i][1].length-3)){
        var index = parseInt(info[i][1].charAt(info[i][1].length-1));
        var width = info[j][3];
        var x_coordinate = info[j][4];
      
        var new_x = x_coordinate+width;
      
        info[i][3] = width;
        info[i][4] = new_x; 
          break;
        }
        
      }
    }
  }
  console.log(info);
}


//lstnodes passed in is an ordered pair of destination x and y values
/*
function drawTreeList(originx, originy, lstnodes){
  for (int i = 0; i < lstnodes; i++){
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(originx, originy);
    ctx.lineTo(lstnodes[i][0], lstnodes[i][0]);
    ctx.stroke();
  }
}
  
  console.log(nchildren);
*/


</script>
