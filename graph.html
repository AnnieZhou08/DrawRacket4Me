<html>
  <canvas id = "myCanvas", width = "1280", height = "700", style = "border: 1px, solid, black; margin-top:10%">
      Your browser does not support HTML5 canvas tag
  </canvas>
</html>

<script>
var ProgressStage = {
  OPENBRACKET : 1,
  ARGUMENTS : 3,
  CLOSEBRACKET : 4  
}

// design scheme:
/*
There are two types of constructing a graph:
'((A (B C D))
  (B (E F G))
  (C (D B E))) ... or
  
(list (list A (list B C D))
      (list B (list E F G))
      (list C (list D B E)))
      
Note that graph always opens with 1 extra bracket. The brackets
in the middle come in 2 pairs, and each node has 2 pairs.
*/
function processGraph(block){
  var thisProcessStage = ProgressStage.OPENBRACKET;
  var numOpenBrackets = 0;
  var currentArgument = 0;
  var arguments = [];
  var edge = [];
  var currentEdge = 0;
  var argument = "";
  
  for (var i = 0; i < block.length; i++){
    var c = block.charAt(i);
    
    switch(thisProcessStage){
      case ProgressStage.OPENBRACKET:
        if(c == " " || c == "'") continue;
        else if(c == "(" && numOpenBrackets == 0) numOpenBrackets++;
        else if(c == "("){
          numOpenBrackets++;
          thisProcessStage = ProgressStage.ARGUMENTS;
        } else {
          continue;
        }
        break;
      
      case ProgressStage.ARGUMENTS:
        if(arguments.length == currentArgument){
          arguments[currentArgument] = [];
        }
        if (c == " "){
          if(argument == "list"){
            argument ="";
          }else{
            edge[currentEdge] = argument;
            currentEdge++;
            argument = "";
          }
        } else if (c == "("){
          if (argument == "list"){
            argument ="";
          }
          numOpenBrackets++;
        } else if (c == ")"){
          numOpenBrackets--;
          if(numOpenBrackets == 1){
            arguments[currentArgument]=edge;
            edge = [];
            currentEdge = 0;
            currentArgument++;
            thisProcessStage = ProgressStage.OPENBRACKET;
          } else if (numOpenBrackets == 0){
            break;
          } else {
            edge[currentEdge] = argument;
            argument = "";
          }
        } else{
          argument += c;
        }
        break;
    }
  }
  console.log(arguments);
  processGraphArguments(arguments);
}
  
function processGraphArguments(arguments){
  var numNodes = arguments.length;
  var startx = window.innerWidth/2;
  var starty = window.innerHeight/2;
  var radius = 3/4 * starty;
  var angle = 2*Math.PI/numNodes;
  
  var positions = [numNodes];
  
  for(var i = 0; i < arguments.length; i++){
    var node = arguments[i][0];
    var x = radius * Math.cos(angle*i) + startx;
    var y = radius * Math.sin(angle*i) + starty;
    
    positions[i] = new Array(node, x, y);
  }
  console.log(positions);
  drawGraph(arguments, positions);
}
  
function drawGraph(arguments, positions){
  var canvas = document.getElementById("myCanvas");
  var ctx = canvas.getContext("2d");
  for (var i = 0; i < arguments.length; i++){
    var node = arguments[i][0];
    var start = findPosition(node, positions);
    var startx = start[0];
    var starty = start[1];
    for (var j = 1; j < arguments[i].length; j++){
      ctx.moveTo(startx, starty);
      var neighbour = arguments[i][j];
      var destination = findPosition(neighbour, positions);
      var destx = destination[0];
      var desty = destination[1];
      ctx.lineTo(destx, desty);
      ctx.stroke();
    }
  }
  for (var i = 0; i < positions.length; i++){
    ctx.beginPath();
    ctx.arc(positions[i][1],positions[i][2],20,0,2*Math.PI);
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.stroke();
    
    ctx.font = "18px Times New Roman";
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    ctx.fillText(positions[i][0], positions[i][1], positions[i][2]); //can do because positions is filled in order of arguments;
  }
}
function findPosition(node, positions){
  console.log(node.toString());
  for (var i = 0; i < positions.length; i++){
    if (node == positions[i][0]){
      return positions[i].slice(1);
    }
  }
  throw "Error: node not found";
}

</script>